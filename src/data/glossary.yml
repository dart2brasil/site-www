- term: "Application package"
  short_description: |-
    Um pacote Dart que contém uma aplicação executável.
  long_description: |-
    Um _application package_ (pacote de aplicação) é um pacote Dart que
    contém um programa ou aplicativo com um [main entrypoint](#entrypoint).
    Destinado a ser executado diretamente, seja na linha de comando, em um navegador,
    ou por outro embedder, como o fornecido pelo Flutter.

    Pacotes de aplicação podem ter [dependencies][] em outros [packages][],
    mas nunca são dependências de outros pacotes.
    Diferente de pacotes regulares, eles não são destinados a serem compartilhados.

    Pacotes de aplicação devem incluir seus [lockfiles][] no controle de versão,
    para que todos trabalhando na aplicação e todos os locais onde a
    aplicação é implantada tenham um conjunto consistente de dependências.

    [main entrypoint]: #entrypoint
    [dependencies]: #dependency
    [packages]: #package
    [lockfiles]: #lockfile
    [version constraints]: #version-constraint
  related_links:
    - text: "Layout de pacotes"
      link: "/tools/pub/package-layout"
      type: "doc"
    - text: "Filosofia de versionamento do Pub"
      link: "/tools/pub/versioning"
      type: "doc"
  labels:
    - "pub"
    - "packages"

- term: "Assist"
  short_description: |-
    Uma edição de código automatizada e local direcionada a fazer melhorias comuns no código.
  long_description: |-
    Um assist é uma edição de código automatizada e local direcionada a fazer melhorias
    comuns no código.
    Exemplos de assists incluem converter declarações `switch` em expressões `switch`,
    inverter os blocos `then` e `else` em uma declaração `if`,
    e inserir widgets em uma estrutura de widgets.
  related_links:
    - text: "Refactor"
      link: "#refactor"
      type: "term"
  labels:
    - "tools"
    - "analyzer"
  alternate:
    - "Quick assist"

- term: "Bottom type"
  short_description: |-
    Um tipo que não tem valores e é um subtipo de todos os outros tipos.
  long_description: |-
    O **bottom type** (tipo inferior) em Dart é o tipo que **não tem valores** e é
    considerado um [**subtype**](/resources/glossary#subtype) de todos os outros tipos.

    Em Dart, o bottom type é representado pelo tipo `Never`.

    Isso significa que um valor do tipo `Never` pode ser usado em qualquer lugar,
    porque tal valor nunca pode realmente existir.
    É mais frequentemente usado como o **tipo de retorno** de funções para
    indicar que elas **nunca retornam**, como aquelas que
    lançam exceções ou entram em loop infinito.

    Por exemplo, a seguinte função `fail` sempre lança uma exceção,
    então ela é declarada com um tipo de retorno `Never` para
    indicar que ela nunca retorna:

    ```dart
    Never fail(String message) {
      throw Exception(message);
    }

    void main() {
      String result = fail('Oops'); // OK: Never is a subtype of String.
    }
    ```

    Como `fail` nunca retorna, atribuí-la a uma `String` é permitido.

  related_links:
    - text: "Tipos integrados"
      link: "/language/built-in-types"
      type: "doc"
    - text: "Never para código inalcançável"
      link: "/null-safety/understanding-null-safety#never-for-unreachable-code"
      type: "doc"
    - text: "Bottom types na teoria de tipos"
      link: "https://en.wikipedia.org/wiki/Bottom_type"
      type: "external"
  labels:
    - "type system"
    - "language"
  alternate:
    - "Never"

- term: "Callback"
  short_description: |-
    Uma função passada como argumento para outra função para ser chamada posteriormente.
  long_description: |-
    Um **callback** é uma função que você passa como argumento para outra
    função para que ela possa ser invocada (ou "chamada de volta") em um momento posterior.

    Callbacks são frequentemente usados para:

    - Manipulação de eventos.
    - Personalização do comportamento de APIs.
    - Operações assíncronas, como responder ao resultado de um future.

    Por exemplo, no seguinte trecho, a função `printResult` é passada
    como callback para `doOperation`, e é chamada após a operação terminar:

    ```dart
    void doOperation(int a, int b, void Function(int) callback) {
      final result = a + b;
      callback(result);
    }

    void printResult(int value) {
      print('The result is $value.');
    }

    void main() {
      doOperation(3, 4, printResult); // Prints: The result is 7.
    }
    ```
  related_links:
    - text: "Tipos de função"
      link: "/language/functions#function-types"
      type: "doc"
    - text: "Futures"
      link: "/libraries/dart-async#future"
      type: "doc"
  labels:
    - "language"
    - "asynchronous"
  alternate:
    - "Function callback"
    - "Callback function"

- term: "Closurization"
  short_description: |-
    O processo de transformar um método ou função em um closure.
  long_description: |-
    **Closurization** (closurização) é o processo onde o Dart transforma um
    método ou função em um objeto de função (ou _tear-off_) que
    pode ser armazenado, passado ou invocado posteriormente.

    Um tear-off é uma referência a uma função ou método existente que é avaliado
    como um objeto de função para aquela entidade, mas não a chama.
    Quando você faz tear-off de uma função, o runtime (ou compilador) a envolve
    em um closure para que ela se comporte como qualquer outro objeto de função em Dart.

    Exemplo:

    ```dart
    class Greeter {
      void greet(String name) {
        print('Hello, $name!');
      }
    }

    void main() {
      final greeter = Greeter();

      // Tear-off of the instance method `greet`.
      final sayHello = greeter.greet;

      sayHello('Dart'); // Prints: Hello, Dart!
    }
    ```

    Neste exemplo, `greeter.greet` é closurizado em
    um objeto de função que captura a instância `greeter`.
    Quando você chama `sayHello`, ele executa como se
    você tivesse chamado `greeter.greet(...)` diretamente.

    A closurização garante que tear-offs possam ser
    usados onde quer que uma função seja esperada.
  related_links:
    - text: "Funções em Dart"
      link: "/language/functions"
      type: "doc"
    - text: "Tear-offs"
      link: "/language/functions#tear-offs"
      type: "doc"
  labels:
    - "language"
    - "functions"
  alternate:
    - "Tear-offs"

- term: "Combinator"
  short_description: |-
    Uma cláusula de palavra-chave que limita ou modifica o que é importado ou exportado.
  long_description: |-
    Em Dart, um **combinator** (combinador) é uma cláusula que
    segue uma diretiva `import` ou `export` para limitar ou modificar
    o conjunto de nomes trazidos para o escopo.

    Dart suporta dois tipos de combinadores:

    - `show` — inclui explicitamente nomes específicos.
    - `hide` — exclui nomes específicos.

    Combinadores ajudam a controlar a poluição do namespace e
    evitar conflitos quando múltiplas bibliotecas definem símbolos com o mesmo nome.

    Exemplo usando `show`:

    ```dart
    import 'dart:math' show pi, sqrt;

    void main() {
      print(pi);      // Accessible
      print(sqrt(9)); // Accessible
      // print(Random()); // Error: Random is not imported.
    }
    ```

    Exemplo usando `hide`:

    ```dart
    import 'dart:math' hide pi;

    void main() {
      // print(pi); // Error: pi is hidden.
      print(Random()); // Accessible
    }
    ```
  related_links:
    - text: "Bibliotecas e imports"
      link: "/language/libraries"
      type: "doc"
    - text: "Organizando um pacote"
      link: "/tools/pub/create-packages#organizing-a-package"
      type: "doc"
  labels:
    - "language"
    - "import/export"
  alternate:
    - "import combinator"
    - "show/hide combinator"

- term: "Context type"
  short_description: |-
    O tipo que o código ao redor espera de uma expressão.
  long_description: |-
    O **context type** (tipo de contexto) é o tipo que o código ao redor espera
    de uma expressão, como um tipo de variável, um tipo de parâmetro ou um
    tipo de retorno.

    Dart usa o tipo de contexto para interpretar e inferir significado
    de expressões, incluindo:

    - **Inferência de tipo** ("inferência descendente"):

      ```dart
      List<int> list = [];
      ```

      O tipo de contexto `List<int>` permite ao compilador inferir o tipo da lista como `<int>[]`.

    - **Downcast implícito**:

      ```dart
      String asString(dynamic value) => value;
      ```

      O contexto de retorno é `String`, então Dart insere um downcast implícito.

    - **Interpretação de literais**:

      ```dart
      double d = 0;
      ```

      O tipo de contexto `double` faz `0` se comportar como `0.0`.

    - **Abreviação de acesso estático** (dot shorthand):

      ```dart
      int x = .parse(input);
      ```

      O tipo de contexto é `int`, então `.parse` resolve para `int.parse(input)`.

    Algumas expressões não têm tipo de contexto, incluindo:

      - **Quando usadas como declarações**:
        Expressões como `set.remove(value);` são usadas apenas por seu
        efeito, não por seu valor, então nenhum tipo é esperado.

      - **Quando o tipo de contexto é inferido da expressão**:
        Por exemplo, em `var list = [1];`, o literal de lista não tem tipo de contexto.
        Dart infere `List<int>` do conteúdo e atribui esse tipo à variável.

  related_links:
    - text: "Inferência de tipo"
      link: "/language/type-system#type-inference"
      type: "doc"
    - text: "Downcast implícito de dynamic"
      link: "/language/type-system#implicit-downcasts-from-dynamic"
      type: "doc"
  labels:
    - "language"
    - "type system"

- term: "Code asset"
  short_description: |-
    Código nativo compilado que é empacotado com um app Dart usando um build hook
    e pode ser usado através de `dart:ffi`.
  long_description: |-
    Um **code asset** (ativo de código) é código compilado que não está escrito em Dart mas
    pode ser empacotado e usado por uma aplicação Dart.
    Exemplos incluem bibliotecas compartilhadas (`.so`, `.dll`, `.dylib`) construídas
    em linguagens como C, C++, ou Rust.

    Code assets podem ser empacotados com um pacote Dart usando um [build hook][].
    Código Dart pode chamar esses assets usando [FFI][].

    > Historicamente, code assets também eram referidos
    > como **native assets** ou **native code assets**.

    Code assets são úteis para:

    * Integrar com bibliotecas nativas existentes.
    * Acessar capacidades do sistema não expostas diretamente em Dart.
    * Compartilhar funcionalidade crítica de desempenho entre plataformas.

    Por exemplo, uma aplicação Dart poderia incluir uma biblioteca nativa `.so`
    que expõe funções específicas, e chamar essas funções de Dart.

    [build hook]: /tools/hooks
    [FFI]: /interop/c-interop
  related_links:
    - text: "Interoperabilidade C usando dart:ffi"
      link: "/interop/c-interop/"
      type: "doc"
    - text: "Hooks"
      link: "/tools/hooks"
      type: "doc"
  labels:
    - "interop"
    - "libraries"
    - "packages"
  alternate:
    - "Native asset"
    - "Native code asset"

- term: "Constant context"
  short_description: |-
    Uma região de código onde a palavra-chave const está implícita e
    tudo dentro dessa região deve ser uma constante.
  long_description: |-
    Um _constant context_ (contexto constante) é uma região de código na qual não
    é necessário incluir a palavra-chave `const` porque está implícito pelo
    fato de que tudo naquela região é obrigatório ser uma constante.
    Os seguintes locais são contextos constantes:

    - Tudo dentro de um literal de list, map ou set que é prefixado pela
      palavra-chave `const`. Por exemplo:

      ```dart
      var l = const [/*constant context*/];
      ```

    - Os argumentos dentro de uma invocação de um construtor constante.
      Por exemplo:

      ```dart
      var p = const Point(/*constant context*/);
      ```

    - O inicializador para uma variável que é prefixada pela palavra-chave `const`.
      Por exemplo:

      ```dart
      const v = /*constant context*/;
      ```

    - Anotações.

    - A expressão em uma cláusula `case`. Por exemplo:

      ```dart
      void f(int e) {
        switch (e) {
          case /*constant context*/:
            break;
        }
      }
      ```
  related_links:
    - text: "Variáveis final e const"
      link: "/language/variables#final-and-const"
      type: "doc"
    - text: "Não use const redundantemente"
      link: "/effective-dart/usage#dont-use-const-redundantly"
      type: "doc"
  labels:
    - "language"
    - "const"
    - "understanding diagnostics"
  alternate:
    - "Implicit const"

- term: "Dart SDK constraint"
  short_description: |-
    As versões do Dart que um pacote suporta.
  long_description: |-
    O intervalo de versões do Dart SDK que um pacote declara que suporta.
    Uma restrição de SDK é especificada usando a sintaxe normal de [version constraint][],
    mas em uma seção especial `environment` [in the pubspec][].

    [version constraint]: #version-constraint
    [in the pubspec]: /tools/pub/pubspec#sdk-constraints
  related_links:
    - text: "Restrições de SDK no pubspec"
      link: "/tools/pub/pubspec#sdk-constraints"
      type: "doc"
    - text: "Versões da linguagem"
      link: "/resources/language/evolution#language-versioning"
      type: "doc"
  labels:
    - "pub"
    - "packages"

- term: "Definite assignment"
  short_description: |-
    A determinação de se uma variável definitivamente recebeu
    um valor antes de ser usada.
  long_description: |-
    A análise de definite assignment (atribuição definitiva) é o processo de determinar, para cada
    variável local em cada ponto no código, qual das seguintes afirmações é verdadeira:

    - A variável definitivamente recebeu um valor
      (_definitely assigned_ - definitivamente atribuída).
    - A variável definitivamente não recebeu um valor
      (_definitely unassigned_ - definitivamente não atribuída).
    - A variável pode ou não ter recebido um valor,
      dependendo do caminho de execução tomado para chegar naquele ponto.

    A análise de definite assignment ajuda a encontrar problemas no código,
    como locais onde uma variável que pode não ter recebido
    um valor está sendo referenciada, ou
    locais onde uma variável que só pode receber um valor uma vez está
    sendo atribuída depois que pode já ter recebido um valor.

    Por exemplo, no código a seguir a variável `s` está
    definitivamente não atribuída quando é passada como argumento para `print`:

    ```dart
    void f() {
      String s;
      print(s);
    }
    ```

    Mas no código a seguir, a variável `s` está definitivamente atribuída:

    ```dart
    void f(String name) {
      String s = 'Hello $name!';
      print(s);
    }
    ```

    A análise de definite assignment pode até dizer se
    uma variável está definitivamente atribuída (ou não atribuída) quando
    há múltiplos caminhos de execução possíveis.
    No código a seguir a função `print` é chamada se
    a execução passar pelo ramo true ou false da
    declaração `if`, mas como `s` é atribuída não importa qual ramo é tomado,
    ela está definitivamente atribuída antes de ser passada para `print`:

    ```dart
    void f(String name, bool casual) {
      String s;
      if (casual) {
        s = 'Hi $name!';
      } else {
        s = 'Hello $name!';
      }
      print(s);
    }
    ```

    Na análise de fluxo, o final da declaração `if` é referido
    como um _join_ (junção) — um local onde dois ou mais caminhos de execução se juntam novamente.
    Onde há um join, a análise diz que
    uma variável está definitivamente atribuída se está definitivamente atribuída ao longo
    de todos os caminhos que estão se juntando, e definitivamente não atribuída se
    está definitivamente não atribuída ao longo de todos os caminhos.

    Às vezes uma variável é atribuída um valor em um caminho mas não em outro,
    caso em que a variável pode ou não ter recebido um valor.
    No exemplo a seguir, o ramo true da declaração `if` pode ou
    não ser executado, então a variável pode ou não ser atribuída um valor:

    ```dart
    void f(String name, bool casual) {
      String s;
      if (casual) {
        s = 'Hi $name!';
      }
      print(s);
    }
    ```

    O mesmo é verdade se houver um ramo false que
    não atribui um valor a `s`.

    A análise de loops é um pouco mais complicada,
    mas segue o mesmo raciocínio básico.
    Por exemplo, a condição em um loop `while` é sempre executada,
    mas o corpo pode ou não ser. Então, assim como uma declaração `if`,
    há um join no final da declaração `while` entre
    o caminho no qual a condição é `true` e
    o caminho no qual a condição é `false`.
  related_links:
    - text: "Especificação de definite assignment"
      link: "https://github.com/dart-lang/language/blob/main/resources/type-system/flow-analysis.md"
      type: "doc"
    - text: "Entendendo a análise de definite assignment"
      link: "/null-safety/understanding-null-safety#definite-assignment-analysis"
      type: "doc"
  labels:
    - "language"
    - "flow analysis"
    - "understanding diagnostics"

- term: "Dependency"
  short_description: |-
    Um pacote Dart do qual um pacote depende.
  long_description: |-
    Uma dependency (dependência) é qualquer outro [package][] Dart do qual um pacote depende.
    Se seu pacote quer importar código de algum outro pacote,
    aquele pacote deve ser uma dependência sua primeiro.
    Dependências são especificadas no arquivo [pubspec][] do seu pacote
    com a sintaxe descrita em [Package dependencies][].

    Para visualizar as dependências usadas por um pacote, use [`pub deps`][].

    [package]: #package
    [pubspec]: /tools/pub/pubspec
    [Package dependencies]: /tools/pub/dependencies
    [`pub deps`]: /tools/pub/cmd/pub-deps
  related_links:
    - text: "Dependências de pacotes"
      link: "/tools/pub/dependencies"
      type: "doc"
    - text: "pub deps"
      link: "/tools/pub/cmd/pub-deps"
      type: "doc"
  labels:
    - "pub"
    - "packages"

- term: "Dependency source"
  short_description: |-
    Um tipo de local de onde o pub pode obter pacotes.
  long_description: |-
    Um tipo de repositório ou local de onde o pub pode recuperar pacotes.
    Uma source (fonte) não é um local específico como o site pub.dev ou uma URL git específica.
    Cada source descreve um procedimento geral para acessar um pacote.

    Como exemplo, _git_ é uma das dependency sources suportadas.
    A source git sabe como baixar pacotes dada uma URL git.
    Várias [supported sources][] diferentes estão disponíveis.

    [supported sources]: /tools/pub/dependencies#dependency-sources
  related_links:
    - text: "Dependency sources"
      link: "/tools/pub/dependencies#dependency-sources"
      type: "doc"
  labels:
    - "pub"
    - "packages"

- term: "Entrypoint"
  short_description: |-
    Uma biblioteca Dart que é invocada diretamente por uma implementação Dart.
  long_description: |-
    No contexto geral do Dart, um _entrypoint_ (ponto de entrada) é
    uma biblioteca Dart que é invocada diretamente por uma implementação Dart.
    Por exemplo, quando você passa uma biblioteca Dart como argumento de linha de comando para
    a VM Dart standalone, aquela biblioteca é o entrypoint.
    Em outras palavras, é geralmente o arquivo `.dart` que contém `main()`.

    No contexto do pub, um _entrypoint package_ ou _root package_ é
    a raiz de um grafo de dependências.
    Geralmente será uma aplicação.
    Quando você executa seu app, ele é o entrypoint package.
    Todo outro pacote do qual ele depende não será um entrypoint naquele contexto.

    Um pacote pode ser um entrypoint em alguns contextos e não em outros.
    Digamos que seu app use um pacote `A`.
    Quando você executa seu app, `A` não é o entrypoint package.
    No entanto, se você for para `A` e executar seus testes, naquele contexto,
    ele _é_ o entrypoint já que seu app não está envolvido.
  related_links:
    - text: "Entrypoint directory"
      link: "#entrypoint-directory"
      type: "term"
  labels:
    - "pub"
    - "packages"
    - "language"
  alternate:
    - "Entry point"
    - "Main function"

- term: "Entrypoint directory"
  short_description: |-
    Um diretório que contém entrypoints Dart.
  long_description: |-
    Um _entrypoint directory_ (diretório de ponto de entrada) é um diretório dentro do seu [package][] Dart que
    pode conter [Dart entrypoints][].

    O Pub tem uma lista desses diretórios: `benchmark`, `bin`, `example`,
    `test`, `tool`, e `web` (e `lib`, para [Flutter apps][]).
    Quaisquer subdiretórios desses (exceto `bin`) também podem conter entrypoints.

    [package]: #package
    [Dart entrypoints]: #entrypoint
    [Flutter apps]: https://docs.flutter.dev/packages-and-plugins/developing-packages
  related_links:
    - text: "Entrypoint"
      link: "#entrypoint"
      type: "term"
    - text: "Pacotes e plugins Flutter"
      link: "https://docs.flutter.dev/packages-and-plugins/developing-packages"
      type: "doc"
  labels:
    - "pub"
    - "packages"

- term: "Function"
  short_description: |-
    Um termo abrangente para se referir a funções de nível superior, funções locais,
    métodos estáticos e métodos de instância.
  related_links:
    - text: "Visão geral de funções"
      link: "/language/functions"
      type: "doc"
    - text: "Métodos de instância"
      link: "/language/methods"
      type: "doc"
  labels:
    - "language"
    - "umbrella term"
  alternate:
    - "Procedure"

- term: "Immediate dependency"
  short_description: |-
    Uma dependência que um pacote Dart usa diretamente.
  long_description: |-
    Uma immediate dependency (dependência imediata) é uma [dependency][] que um
    pacote usa diretamente e declara ele mesmo.
    As dependências que você lista no seu arquivo [`pubspec.yaml`][] são
    as dependências imediatas do seu pacote.
    Todas as outras dependências são [transitive dependencies][].

    [dependency]: #dependency
    [`pubspec.yaml`]: /tools/pub/pubspec
    [transitive dependencies]: #transitive-dependency
  related_links:
    - text: "Dependências de pacotes"
      link: "/tools/pub/dependencies"
      type: "doc"
    - text: "Transitive dependency"
      link: "#transitive-dependency"
      type: "term"
  labels:
    - "pub"
    - "packages"
  alternate:
    - "Direct dependency"

- term: "Immutable"
  short_description: |-
    Um objeto cujo estado, incluindo todos os valores aninhados, não pode ser alterado após sua criação.
  long_description: |-
    Um objeto immutable (imutável) é aquele cujo estado não pode ser modificado após sua criação.
    Quando um objeto é imutável, todos os seus campos devem ser `final` (não podem ser reatribuídos), e
    os valores desses campos devem ser eles mesmos imutáveis (não podem ser mutados).
    Isso ajuda a garantir consistência e permite uso mais seguro em código concorrente ou reativo.

    Em Dart, uma classe é imutável se você:

    * Declarar todos os campos como final, para que não possam ser reatribuídos.
    * Garantir que os valores dos campos sejam eles mesmos imutáveis.
    * Opcionalmente, usar a anotação `@immutable` do pacote meta.
      Isso permite que o analisador avise se algum campo não for final ou se referir a um tipo mutável.

    Adicionalmente, todos os valores const do Dart são imutáveis. Por exemplo, `const [1, 2, 3]`
    cria uma lista imutável. Se uma classe tem um construtor `const` (não-factory), então
    todos os seus campos devem ser final.

    Exemplo:

      ```dart
      import 'package:meta/meta.dart';

      @immutable
      class User {
        final String name;
        final int age;

        const User(this.name, this.age);
      }
      ```

    No exemplo anterior, uma vez criada, você não pode modificar a instância `User`.
    Você deve criar uma nova para alterar quaisquer dados.

  related_links:
    - text: "final"
      link: "/language/class-modifiers#final"
      type: "term"
  labels:
    - "language"
  alternate:
    - "Read-only"
    - "Unchangeable"

- term: "Irrefutable pattern"
  short_description: |-
    Um pattern que sempre corresponde.
  long_description: |-
    _Irrefutable patterns_ (padrões irrefutáveis) são patterns que sempre correspondem.
    Padrões irrefutáveis são os únicos padrões que podem aparecer em
    _irrefutable contexts_ (contextos irrefutáveis): os contextos de pattern de [_declaration_][] e [_assignment_][].

    [_declaration_]: /language/patterns#variable-declaration
    [_assignment_]: /language/patterns#variable-assignment
  related_links:
    - text: "Lugares onde patterns podem aparecer"
      link: "/language/patterns#places-patterns-can-appear"
      type: "doc"
    - text: "Mergulhe em patterns e records do Dart"
      link: "https://codelabs.developers.google.com/codelabs/dart-patterns-records"
      type: "tutorial"
  labels:
    - "language"
    - "patterns"
  alternate:
    - "irrefutable context"

- term: "Mixin application"
  short_description: |-
    Uma classe criada quando um mixin é aplicado a uma classe.
  long_description: |-
    Uma _mixin application_ (aplicação de mixin) é a classe criada quando
    um mixin é aplicado a uma classe.
    Por exemplo, considere as seguintes declarações:

    ```dart
    class A {}

    mixin M {}

    class B extends A with M {}
    ```

    A classe `B` é uma subclasse da mixin application de `M` a `A`,
    às vezes nomenclaturada como `A+M`. A classe `A+M` é uma subclasse de `A` e
    tem membros que são copiados de `M`.

    Você pode dar um nome real a uma mixin application definindo-a como:

    ```dart
    class A {}

    mixin M {}

    class A_M = A with M;
    ```

    Dada essa declaração de `A_M`, a seguinte declaração de `B` é
    equivalente à declaração de `B` no exemplo original:

    ```dart
    class B extends A_M {}
    ```
  related_links:
    - text: "Mixins em Dart"
      link: "/language/mixins"
      type: "doc"
  labels:
    - "language"
    - "understanding diagnostics"
  alternate:
    - "with mixin"

- term: "Late"
  id: "late"
  short_description: |-
    Uma palavra-chave que habilita inicialização diferida de variáveis e é
    tipicamente usada com variáveis não-anuláveis.
  long_description: |-
    A palavra-chave `late` em Dart é usada para indicar que uma variável
    será inicializada mais tarde, após sua declaração, mas antes de ser usada.
    Isso ajuda a evitar a necessidade de tornar uma variável anulável (`?`) quando você
    sabe que ela definitivamente receberá um valor, apenas não imediatamente.

    Usar `late` adia a inicialização, permitindo que você escreva código mais
    flexível e legível, especialmente ao lidar com dependências
    ou configuração complexa.

    Por exemplo:
    ```dart
    late String description;

    void setup() {
      description = 'This will be initialized before use.';
    }
    ```

    Tenha cuidado com variáveis late que fazem parte de uma API pública.
    Se um cliente acessar a variável antes de ser inicializada,
    ele encontrará um `LateInitializationError`, que fornece
    pouco contexto. Nesses casos, considere usar uma
    variável anulável privada com um getter público que lance um
    erro descritivo (por exemplo, `StateError`) se acessado muito cedo, pois
    isso pode oferecer feedback mais claro aos usuários da API, apesar da complexidade
    adicional.

    Você também pode usar `late final` quando a variável deve ser definida apenas uma vez.
    Isso é útil em cenários onde o valor não está disponível no momento da
    construção do objeto, como dependências cíclicas em grafos de objetos.

    Exemplo:

    ```dart
    class LinkedQueue<T> {
      late final QueueLink<T> _head;

      LinkedQueue() {
        _head = QueueLink<T>._head(owner: this); // Cyclic reference between objects
      }
    }
    ```

    Seja cauteloso: se uma variável late for acessada antes de ser inicializada
    ou nunca for inicializada, isso causará um erro em tempo de execução.

  related_links:
    - text: "Null safety em Dart"
      link: "/null-safety"
      type: "doc"
    - text: "Variáveis late"
      link: "/language/variables#late-variables"
      type: "doc"
    - text: "Erro: LateInitializationError"
      link: "https://api.dart.dev/stable/2.7.2/dart-core/LateInitializationError-class.html"
      type: "api"
  labels:
    - "language"
    - "variables"
    - "null safety"
  alternate:
    - "late keyword"
    - "deferred initialization"
    - "late final"

- term: "Library"
  short_description: |-
    Uma única unidade de compilação em Dart, composta por um
    arquivo Dart primário e suas partes.
  long_description: |-
    Uma _library_ (biblioteca) Dart é uma única unidade de compilação em Dart,
    composta por um arquivo `.dart` primário e qualquer número opcional de [parts][].
    Bibliotecas têm seu próprio escopo privado.

    [parts]: #part-file
  related_links:
    - text: "Part file"
      link: "#part-file"
      type: "term"
  labels:
    - "language"
    - "libraries"

- term: "Lockfile"
  short_description: |-
    Um arquivo chamado pubspec.lock que especifica as versões de cada dependência.
  long_description: |-
    Um arquivo chamado `pubspec.lock` que especifica as
    versões concretas e outras informações de identificação para cada
    dependência [immediate][] e [transitive][] de que um pacote depende.

    Diferente do [pubspec][], que lista apenas dependências imediatas e
    permite intervalos de versões, o lockfile fixa de forma abrangente
    o grafo de dependências inteiro para versões específicas de pacotes.
    Um lockfile garante que você possa recriar a
    configuração exata de pacotes usada por uma aplicação.

    O lockfile é gerado automaticamente para você pelo pub quando você executa
    [`pub get`][], [`pub upgrade`][], ou [`pub downgrade`][].
    O Pub inclui um [content hash][] para cada dependência
    para verificar durante resoluções futuras.

    Se seu pacote é um [application package][],
    você tipicamente incluirá isso no controle de versão.
    Para pacotes regulares (biblioteca), você geralmente não incluirá.

    [immediate]: #immediate-dependency
    [transitive]: #transitive-dependency
    [pubspec]: /tools/pub/pubspec
    [`pub get`]: /tools/pub/cmd/pub-get
    [`pub upgrade`]: /tools/pub/cmd/pub-upgrade
    [`pub downgrade`]: /tools/pub/cmd/pub-downgrade
    [application package]: #application-package
    [content hash]: #pub-content-hash
  related_links:
    - text: "pub get"
      link: "/tools/pub/cmd/pub-get"
      type: "doc"
    - text: "pub upgrade"
      link: "/tools/pub/cmd/pub-upgrade"
      type: "doc"
    - text: "pub downgrade"
      link: "/tools/pub/cmd/pub-downgrade"
      type: "doc"
  labels:
    - "pub"
    - "packages"
  alternate:
    - "pubspec.lock"

- term: "Obviously typed"
  short_description: |-
    Uma expressão cujo tipo pode ser mecanicamente determinado sem ambiguidade.
  long_description: |-
    Uma expressão em Dart é considerada **obviously typed** (obviamente tipada) quando
    seu tipo é imediatamente claro a partir de sua sintaxe,
    sem necessidade de inferência ou análise complexa.

    Este conceito é principalmente usado em regras de lint como
    `omit_obvious_local_variable_types` e `specify_nonobvious_property_types`
    para decidir se uma anotação de tipo explícita é redundante ou necessária.

    ### Expressões obviously typed

    Os seguintes tipos de expressões são considerados obviously typed:

    - Literais não-coleção:
      `1`, `true`, `'Hello'`.
    - Literais de coleção com argumentos de tipo explícitos:
      `<int>[]`, `<String, bool>{}`.
    - Literais de list/set homogêneos cujos elementos são obviamente tipados:
      `[1, 2, 3]`, `{true, false}`.
    - Literais de map homogêneos com tipos de chave e valor óbvios:
      `{1: 10, 2: 20}`.
    - Literais de record com tipos óbvios:
      `(1, enabled: true)`.
    - Variáveis locais e parâmetros formais que não foram promovidos.
    - Criação de instância com classes não-genéricas ou argumentos de tipo explícitos:
      `C()`, `Set<int>()`.
    - Cascades com alvos obviamente tipados:
      `StringBuffer('Hello, ')..write('world!')`.
    - Type casts:
      `x as int`.
    - Expressões condicionais com ramos obviamente tipados do mesmo tipo:
      `condition ? 1 : 2`.
    - Type tests:
      `x is String`.
    - Expressões throw:
      `throw Exception()`.
    - Expressões entre parênteses cujo conteúdo é obviamente tipado:
      `('Hello!')`.
    - `this` e type literals:
      `String`.

    Nesta lista, _homogêneo_ significa "onde cada elemento tem o mesmo tipo".
    Por exemplo, `{1: 'one', 2: 'two'}` é um map homogêneo,
    mas `{1: 'one', 1.5: true}` não é.
    Por outro lado, se o tipo de uma expressão requer inferência (por exemplo
    `[1, 2.5]` → `List<num>`), ela **não** é considerada obviously typed.

    Esta distinção ajuda regras de estilo a decidir quando
    aplicar ou omitir anotações de tipo para clareza e consistência.
  related_links:
    - text: "Dart Eficaz: Estilo"
      link: "/effective-dart/style"
      type: "doc"
    - text: "Lint: omit_obvious_local_variable_types"
      link: "/tools/linter-rules/omit_obvious_local_variable_types"
      type: "diagnostic"
    - text: "Lint: specify_nonobvious_property_types"
      link: "/tools/linter-rules/specify_nonobvious_property_types"
      type: "diagnostic"
  labels:
    - "language"
    - "type system"
    - "style"
  alternate:
    - "Obvious expression type"
    - "Clear type"

- term: "Override inference"
  short_description: |-
    Como tipos ausentes em uma declaração de método são inferidos.
  long_description: |-
    Override inference (inferência de sobrescrita) é o processo pelo qual quaisquer tipos ausentes em
    uma declaração de método são inferidos com base nos tipos correspondentes do
    método ou métodos que ele sobrescreve.

    Se um método candidato (o método com informação de tipo ausente)
    sobrescreve um único método herdado, então os
    tipos correspondentes do método sobrescrito são inferidos.
    Por exemplo, considere o seguinte código:

    ```dart
    class A {
      int m(String s) => 0;
    }

    class B extends A {
      @override
      m(s) => 1;
    }
    ```

    A declaração de `m` em `B` é uma candidata porque
    está faltando tanto o tipo de retorno quanto o tipo do parâmetro.
    Como ela sobrescreve um único método (o método `m` em `A`),
    os tipos do método sobrescrito serão usados para inferir
    os tipos ausentes e será como se o método em `B` tivesse sido
    declarado como `int m(String s) => 1;`.

    Se um método candidato sobrescreve múltiplos métodos, e
    o tipo de função de um desses métodos sobrescritos, M<sub>s</sub>,
    é um supertipo dos tipos de função de todos os outros métodos sobrescritos,
    então M<sub>s</sub> é usado para inferir os tipos ausentes.
    Por exemplo, considere o seguinte código:

    ```dart
    class A {
      int m(num n) => 0;
    }

    class B {
      num m(int i) => 0;
    }

    class C implements A, B {
      @override
      m(n) => 1;
    }
    ```

    A declaração de `m` em `C` é uma candidata para override inference porque
    está faltando tanto o tipo de retorno quanto o tipo do parâmetro.
    Ela sobrescreve tanto `m` em `A` quanto `m` em `B`, então o compilador precisa
    escolher um deles do qual os tipos ausentes possam ser inferidos.
    Mas como o tipo de função de `m` em `A` (`int Function(num)`) é
    um supertipo do tipo de função de `m` em `B` (`num Function(int)`),
    a função em `A` é usada para inferir os tipos ausentes. O resultado é
    o mesmo que declarar o método em `C` como `int m(num n) => 1;`.

    É um erro se nenhum dos métodos sobrescritos tem um tipo de função que
    é um supertipo de todos os outros métodos sobrescritos.
  related_links:
    - text: "Herança em Dart"
      link: "/language/extend"
      type: "doc"
  labels:
    - "language"
    - "type inference"
    - "understanding diagnostics"

- term: "Package"
  short_description: |-
    Um diretório com uma coleção de bibliotecas Dart, recursos,
    e um arquivo pubspec.yaml descrevendo-os.
  long_description: |-
    Um _package_ (pacote) Dart é uma coleção de [libraries][] e recursos Dart em
    um diretório, com um arquivo [`pubspec.yaml`][] na raiz daquele diretório.

    Pacotes podem ter [dependencies][] em outros pacotes
    *e* podem ser dependências eles mesmos.
    O diretório `/lib` de um pacote contém as [public libraries][] que
    outros pacotes podem importar e usar.
    Eles também podem incluir scripts para serem executados diretamente.
    Um pacote que não é destinado a ser dependência de
    outros pacotes é um [application package][].
    Pacotes compartilhados são [published][] no pub.dev,
    mas você também pode ter pacotes não publicados.

    Não inclua o [lockfile][] de um pacote no controle de versão,
    já que bibliotecas devem suportar um intervalo de versões de dependências.
    As [version constraints][] das [immediate dependencies][] de um pacote devem
    ser tão amplas quanto possível enquanto ainda garantindo que as dependências sejam
    compatíveis com as versões contra as quais foram testadas.

    Como [semantic versioning][] requer que
    bibliotecas incrementem seus números de versão principal para
    quaisquer mudanças incompatíveis com versões anteriores, pacotes geralmente
    requererão que as versões de suas dependências sejam maiores ou iguais às
    versões que foram testadas e menores que a próxima versão principal.
    Então, se sua biblioteca dependesse do pacote (fictício) `transmogrify` e
    você testou na versão `1.2.1`, sua restrição de versão seria `^1.2.1`.

    [libraries]: #library
    [`pubspec.yaml`]: /tools/pub/pubspec
    [dependencies]: #dependency
    [public libraries]: /tools/pub/package-layout#public-libraries
    [application package]: #application-package
    [published]: /tools/pub/publishing
    [lockfile]: #lockfile
    [version constraints]: #version-constraint
    [immediate dependencies]: #immediate-dependency
    [semantic versioning]: https://semver.org/spec/v2.0.0-rc.1.html
  related_links:
    - text: "Como usar pacotes"
      link: "/tools/pub/packages"
      type: "doc"
    - text: "O arquivo pubspec.yaml"
      link: "/tools/pub/pubspec"
      type: "doc"
    - text: "Publicando pacotes"
      link: "/tools/pub/publishing"
      type: "doc"
  labels:
    - "pub"
    - "packages"
  alternate:
    - "Library package"

- term: "Package uploader"
  short_description: |-
    Um usuário do pub.dev que tem permissões administrativas para um pacote.
  long_description: |-
    Um _package uploader_ (uploader de pacote) é alguém que tem
    permissões administrativas para um pacote.
    Um package uploader pode fazer upload de novas versões do pacote,
    e também pode [add and remove other uploaders][] para aquele pacote.

    Se um pacote tem um [verified publisher][],
    então todos os membros do publisher podem fazer upload do pacote.

    [add and remove other uploaders]: /tools/pub/publishing#uploaders
    [verified publisher]: #verified-publisher
  related_links:
    - text: "Gerenciando uploaders"
      link: "/tools/pub/publishing#uploaders"
      type: "doc"
  labels:
    - "pub"
    - "packages"
  alternate:
    - "Uploader"

- term: "Part file"
  short_description: |-
    Um arquivo fonte Dart que contém uma diretiva `part of`.
  long_description: |-
    Um part file (arquivo de parte) é um arquivo fonte Dart que contém uma diretiva `part of`
    e é incluído em uma biblioteca usando a diretiva `part`.
  related_links:
    - text: "Orientação sobre bibliotecas e partes"
      link: "/tools/pub/create-packages#organizing-a-package"
      type: "doc"
    - text: "Use URIs de biblioteca em diretivas `part of`"
      link: "/effective-dart/usage#do-use-strings-in-part-of-directives"
      type: "doc"
  labels:
    - "language"
    - "libraries"
  alternate:
    - "part"

- term: "Potentially non-nullable"
  short_description: |-
    Um tipo que é não-anulável explicitamente ou
    devido a ser um parâmetro de tipo.
  long_description: |-
    Um tipo é _potentially non-nullable_ (potencialmente não-anulável) se é
    explicitamente não-anulável ou se é um parâmetro de tipo.

    Um tipo é explicitamente não-anulável se é um
    nome de tipo que não é seguido por um ponto de interrogação (`?`).
    Note que existem alguns tipos que são sempre anuláveis, como
    `Null` e `dynamic`, e que `FutureOr` é apenas não-anulável se
    não é seguido por um ponto de interrogação _e_
    o argumento de tipo é não-anulável (como `FutureOr<String>`).

    Parâmetros de tipo são potencialmente não-anuláveis porque o tipo
    de runtime real (o tipo especificado como argumento de tipo) pode ser não-anulável.
    Por exemplo, dada uma declaração de `class C<T> {}`,
    o tipo `C` pode ser usado com um argumento de tipo não-anulável como em `C<int>`.
  related_links:
    - text: "Anulabilidade e generics"
      link: "/null-safety/understanding-null-safety#nullability-and-generics"
      type: "doc"
  labels:
    - "language"
    - "type system"
    - "flow analysis"
    - "understanding diagnostics"
  alternate:
    - "potentially nullable"

- term: "Public library"
  short_description: |-
    Uma biblioteca que está localizada no diretório `lib` de um pacote mas
    não dentro do diretório `lib/src`.
  long_description: |-
    Uma public library (biblioteca pública) é uma biblioteca que está localizada dentro do diretório `lib`
    do pacote mas não dentro do diretório `lib/src`.
  related_links:
    - text: "Organizando as bibliotecas de um pacote"
      link: "/tools/pub/create-packages#organizing-a-package"
      type: "doc"
    - text: "Diretórios públicos de pacotes"
      link: "/tools/pub/package-layout#public-directories"
      type: "doc"
  labels:
    - "language"
    - "libraries"

- term: "Pub content hash"
  short_description: |-
    Hashes SHA256 mantidos pelo pub.dev para validar a integridade de pacotes.
  long_description: |-
    O repositório pub.dev mantém um _content hash_ (hash de conteúdo) SHA256 de
    cada versão de cada pacote que ele hospeda.
    Clientes Pub usam este hash para validar a integridade de pacotes baixados,
    e proteger contra mudanças no repositório fonte.

    Quando `dart pub get` baixa um pacote,
    ele computa o hash do arquivo baixado.
    O hash de cada dependência hospedada é armazenado com a
    [resolution][] no [lockfile][].

    O cliente pub usa este content hash para verificar que
    executar `dart pub get` novamente usando o mesmo lockfile,
    potencialmente em um computador diferente, usa exatamente os mesmos pacotes.

    Se o hash travado não corresponde ao que está atualmente no cache do pub,
    o pub rebaixa o arquivo. Se ainda não corresponder,
    o lockfile é atualizado e um aviso é impresso.

    Para fazer uma discrepância se tornar um erro em vez de um aviso,
    use a opção [`--enforce-lockfile`][] para `dart pub get`.
    Com esta opção, se o pub não conseguir encontrar arquivos de pacote com os mesmos hashes,
    a resolução de dependência falha e o lockfile não é atualizado.

    [resolution]: /tools/pub/cmd/pub-get
    [lockfile]: #lockfile
    [`--enforce-lockfile`]: /tools/pub/cmd/pub-get#enforce-lockfile
  related_links:
    - text: "dart pub get --enforce-lockfile"
      link: "/tools/pub/cmd/pub-get#enforce-lockfile"
      type: "doc"
  labels:
    - "pub"
    - "security"

- term: "Pub system cache"
  short_description: |-
    Um diretório onde o pub armazena pacotes remotos baixados.
  long_description: |-
    Quando o pub obtém um pacote remoto,
    ele o baixa em um único diretório _pub system cache_ (cache do sistema pub).
    No macOS e Linux, este diretório por padrão é `~/.pub-cache`.
    No Windows, o diretório por padrão é `%LOCALAPPDATA%\Pub\Cache`,
    embora sua localização exata possa variar dependendo da versão do Windows.
    Você pode especificar uma localização diferente usando a
    variável de ambiente [`PUB_CACHE`][].

    Uma vez que os pacotes estão no cache do sistema,
    o pub cria um arquivo `package_config.json` que mapeia cada pacote
    usado pela sua aplicação para o pacote correspondente no cache.

    Você só precisa baixar uma versão específica de um pacote uma vez
    e pode então reutilizá-la em quantos pacotes quiser.
    Se você especificar a flag `--offline` para usar pacotes em cache,
    você pode deletar e regenerar seus arquivos `package_config.json`
    sem precisar acessar a rede.

    [`PUB_CACHE`]: /tools/pub/environment-variables
  related_links:
    - text: "Variáveis de ambiente do Pub"
      link: "/tools/pub/environment-variables"
      type: "doc"
  labels:
    - "pub"
    - "packages"
  alternate:
    - "Pub cache"

- term: "Pub workspace"
  short_description: |-
    Uma coleção de pacotes que são desenvolvidos juntos com
    uma resolução compartilhada de suas restrições de dependência.
  long_description: |-
    Um _pub workspace_ associa uma coleção de pacotes locais que são
    tratados como uma única unidade durante o desenvolvimento, habilitando
    resolução compartilhada de suas restrições de dependência.
    Útil para desenvolver em um monorepo.

    Os pacotes têm arquivos `pubspec.lock` e
    `.dart_tool/package_config.json` compartilhados no diretório raiz do workspace.
  related_links:
    - text: "Pub workspaces"
      link: "/tools/pub/workspaces"
      type: "doc"
  labels:
    - "pub"
    - "packages"
  alternate:
    - "Workspace"

- term: "Quick fix"
  short_description: |-
    Uma edição de código automatizada e local direcionada a corrigir o problema reportado por um
    diagnóstico específico.
  related_links:
    - text: "Quick fixes para problemas de análise"
      link: "https://blog.dart.dev/quick-fixes-for-analysis-issues-c10df084971a"
      type: "article"
    - text: "Mensagens de diagnóstico"
      link: "/tools/diagnostic-messages"
      type: "doc"
    - text: "Regras do linter"
      link: "/tools/linter-rules"
      type: "doc"
  labels:
    - "tools"
    - "understanding diagnostics"

- term: "Refactor"
  short_description: |-
    Uma edição de código direcionada a modificações que são não-locais ou que
    requerem interação do usuário.
  long_description: |-
    Um refactor (refatoração) é uma edição de código direcionada a modificações que são não-locais
    ou que requerem interação do usuário.
    Exemplos de refatorações incluem renomear, remover ou extrair código.
  related_links:
    - text: "Assist"
      link: "#assist"
      type: "term"
  labels:
    - "tools"
    - "analysis"

- term: "Refutable pattern"
  short_description: |-
    Um pattern que pode ser testado contra um valor.
  long_description: |-
    Um _refutable pattern_ (padrão refutável) é um pattern que pode ser testado contra um valor para
    determinar se o pattern corresponde ao valor.
    Se não, o pattern _refutes_ (refuta), ou nega, a correspondência.
    Padrões refutáveis aparecem em [_matching contexts_][].

    [_matching contexts_]: /language/patterns#matching
  related_links:
    - text: "Lugares onde patterns podem aparecer"
      link: "/language/patterns#places-patterns-can-appear"
      type: "doc"
    - text: "Mergulhe em patterns e records do Dart"
      link: "https://codelabs.developers.google.com/codelabs/dart-patterns-records"
      type: "tutorial"
  labels:
    - "language"
    - "patterns"
  alternate:
    - "matching contexts"

- term: "Subclass"
  short_description: |-
    Uma classe que herda a implementação de outra classe.
  long_description: |-
    Uma _subclass_ (subclasse) é uma classe que herda a implementação de outra classe
    usando a palavra-chave [`extends`][], ou por [mixin application][].

    ```dart
    // A is a subclass of B; B is the superclass of A.
    class A extends B {}

    // B1 has the superclass `A with M`, which has the superclass A.
    class B1 extends A with M {}
    ```

    Uma relação de subclasse também implica uma relação de [subtype](#subtype) associada.
    Por exemplo, `class A` implicitamente define um tipo associado `A`
    que instâncias da classe `A` habitam.
    Então, `class A extends B` declara não apenas que a classe
    `A` é uma subclasse de `B`, mas também estabelece que o *tipo* `A` é um
    *subtipo* do tipo `B`.

    Relações de subclasse são um subconjunto de relações de subtipo.
    Quando a documentação diz "`S` deve ser um subtipo de `T`",
    está ok para `S` ser uma subclasse de `T`.
    No entanto, o inverso não é verdadeiro: nem todos os subtipos são subclasses.

    [`extends`]: /language/extend
    [mixin application]: #mixin-application
  related_links:
    - text: "Herança em Dart"
      link: "/language/extend"
      type: "doc"
    - text: "Relacionamento de subtipo"
      link: "#subtype"
      type: "term"
  labels:
    - "language"
    - "type system"
  alternate:
    - "child class"

- term: "Shadowing"
  short_description: |-
    Quando uma declaração local oculta outra com o mesmo nome.
  long_description: |-
    **Shadowing** (sombreamento) ocorre quando uma declaração local,
    como uma variável ou parâmetro,
    usa o mesmo nome de uma declaração existente em um escopo externo,
    tornando a externa inacessível dentro do escopo interno.

    Embora válido em Dart, shadowing pode levar a
    código confuso ou comportamento não intencional.
    Como resultado, é geralmente desencorajado a menos que
    usado deliberadamente para melhorar a clareza do seu código.

    ### Exemplo

    Neste exemplo, a variável local `message` dentro
    da função `printMessage` **sombreia** a variável `message` de nível superior:

    ```dart
    final message = 'Global';

    void printMessage() {
      final message = 'Local'; // Shadows the global `message` variable.
      print(message); // Prints: Local
    }

    void main() {
      printMessage();
      print(message); // Prints: Global
    }
    ```

    Shadowing também pode ocorrer em blocos aninhados:

    ```dart
    void main() {
      final value = 10;
      if (true) {
        final value = 20; // Shadows the outer `value` variable.
        print(value);   // Prints: 20
      }
      print(value);     // Prints: 10
    }
    ```
  labels:
    - "language"
  alternate:
    - "variable shadowing"
    - "name shadowing"

- term: "Subtype"
  short_description: |-
    Um tipo que pode ser usado onde quer que um valor de seu supertipo seja esperado.
  long_description: |-
    Uma relação de _subtype_ (subtipo) é onde um valor de um certo tipo é substituível
    onde o valor de outro tipo, o supertipo, é esperado.
    Por exemplo, se `S` é um subtipo de `T`,
    então você pode substituir um valor do tipo `S`
    onde um valor do tipo `T` é esperado.

    Um subtipo suporta todas as operações de seu supertipo
    (e possivelmente algumas operações extras).
    Na prática, isso significa que você pode atribuir o valor de um subtipo
    para qualquer local esperando o supertipo,
    e todos os métodos do supertipo estão disponíveis no subtipo.

    Isso é verdade pelo menos estaticamente.
    Uma API específica pode não permitir a substituição em tempo de execução,
    dependendo de suas operações.

    Algumas relações de subtipo são baseadas na estrutura do tipo,
    como com tipos anuláveis (por exemplo, `int` é um subtipo de `int?`)
    e tipos de função
    (por exemplo, `String Function()` é um subtipo de `void Function()`).

    Subtipos também podem ser introduzidos para classes por
    [implementation](/language/classes#implicit-interfaces)
    ou [inheritance](/language/extend) (direta ou indireta):

    ```dart
    // A is a subtype of B, but NOT a subclass of B.
    class A implements B {}

    // C is a subtype AND a subclass of D.
    class C extends D {}
    ```
  related_links:
    - text: "Subclass"
      link: "#subclass"
      type: "term"
    - text: "Substituindo tipos"
      link: "/language/type-system#substituting-types"
      type: "doc"
  labels:
    - "language"
    - "type system"
  alternate:
    - "subtyping"
    - "subtype polymorphism"

- term: "Transitive dependency"
  short_description: |-
    Uma dependência que um pacote usa indiretamente porque
    uma de suas dependências a requer.
  long_description: |-
    Uma _transitive dependency_ (dependência transitiva) é uma [dependency][] que um pacote usa indiretamente
    porque uma de suas dependências, ou as dependências delas, a requer.

    Se seu pacote depende de A, que por sua vez depende de B que depende de C,
    então A é uma [immediate dependency][] e B e C são transitivas.

    [dependency]: #dependency
    [immediate dependency]: #immediate-dependency
  related_links:
    - text: "Immediate dependency"
      link: "#immediate-dependency"
      type: "term"
  labels:
    - "pub"
    - "packages"

- term: "Tree shaking"
  short_description: |-
    Uma otimização do compilador que remove código não usado.
  long_description: |-
    **Tree shaking** é uma otimização do compilador que
    analisa quais partes do código são realmente usadas por uma aplicação e
    remove todo o resto da saída final.

    Isso torna o programa compilado menor e mais rápido para carregar, já que código morto
    que nunca é referenciado não acaba no binário ou bundle.

    Tree shaking é especialmente importante para apps web e móveis, onde
    o tamanho do código impacta diretamente o tempo de download e desempenho em tempo de execução.

    Por exemplo, se você importar uma biblioteca que define dez funções de nível superior,
    mas seu app chama apenas duas, tree shaking garante
    que as outras oito funções sejam excluídas da saída compilada.
  related_links:
    - text: "Dart compile"
      link: "/tools/dart-compile"
      type: "doc"
    - text: "Bibliotecas & imports"
      link: "/language/libraries"
      type: "doc"
    - text:  "Implantação web"
      link:  "/web/deployment"
      type: "doc"
  labels:
    - "language"
    - "compilation"
    - "optimization"
  alternate:
    - "Dead-code elimination"

- term: "Type alias"
  short_description: |-
    Um nome definido pelo usuário para um tipo existente.
  long_description: |-
    Um **type alias** (alias de tipo) é um nome alternativo que se refere a outro tipo.

    Eles podem ser usados para simplificar definições de tipos complexos,
    melhorar a legibilidade, ou criar significado semântico no código.

    Dart suporta definição de type aliases usando a palavra-chave `typedef`.
    Você pode criar alias para funções, classes e até tipos genéricos.

    ### Exemplos

    #### Alias de tipo de função

    ```dart
    typedef StringTransformer = String Function(String);

    void printTransformed(String input, StringTransformer transformer) {
      print(transformer(input));
    }

    void main() {
      printTransformed('hello', (str) => str.toUpperCase()); // Output: HELLO
    }
    ```

    #### Alias de classe

    ```dart
    class HttpClient {}

    typedef Client = HttpClient;

    Client client = HttpClient();
    ```

    Type aliases não criam novos tipos, eles apenas fornecem nomes alternativos.
  related_links:
    - text: "Palavra-chave `typedef`"
      link: "/language/typedefs"
      type: "doc"
  labels:
    - "language"
    - "type system"
  alternate:
    - "typedef"
    - "alias"

- term: "Variance and variance positions"
  id: "variance"
  short_description: |-
    Como alterar um argumento de tipo de um tipo afeta a relação
    entre o tipo original e o resultante.

    Em Dart, alterar o argumento de tipo de uma
    declaração de tipo (como uma classe) ou tipo de retorno de função, altera a
    relação de tipo geral na mesma direção (covariante).

    No entanto, alterar o tipo dos tipos de parâmetro de uma função, altera a
    relação de tipo geral na direção oposta (contravariante).
  long_description: |-
    Um parâmetro de tipo de uma classe (ou outra declaração de tipo, como um mixin) é
    dito ser _covariant_ (covariante) quando o tipo como um todo
    "co-varia" com o argumento de tipo real.
    Em outras palavras, se o argumento de tipo é substituído por um
    subtipo, então o tipo como um todo também é um subtipo.

    Por exemplo, o parâmetro de tipo da classe `List` é covariante porque
    tipos de list co-variam com seu argumento de tipo: `List<int>` é um subtipo de
    `List<Object>` porque `int` é um subtipo de `Object`.

    Em Dart, todos os parâmetros de tipo de todas as declarações de class, mixin,
    mixin class e enum são covariantes.

    No entanto, tipos de função são diferentes:
    Um tipo de função é covariante em seu tipo de retorno, mas
    o oposto (conhecido como _contravariant_ - contravariante) em seus tipos de parâmetro.
    Por exemplo, o tipo `int Function(int)` é um
    subtipo do tipo `Object Function(int)`, mas é um
    supertipo de `int Function(Object)`.

    Isso faz sentido se você considerar sua [substitutability](#subtype) (substituibilidade).
    Se você chamar uma função com um tipo estático de `int Function(int)`,
    aquela função pode realmente ser do tipo `int Function(Object)` em runtime.
    Baseado no tipo estático, você espera poder passar um `int` para ela.
    Isso será ok já que a função realmente aceita qualquer `Object`,
    e isso inclui todo objeto do tipo `int`.
    Similarmente, o resultado retornado será do tipo `int`,
    que também é o que você espera baseado no tipo estático.

    Portanto, `int Function(Object)` é um subtipo de `int Function(int)`.

    Note que tudo está invertido para tipos de parâmetro.
    Em particular, esta relação de subtipo entre tipos de função requer que
    a relação de subtipo _oposta_ exista para o tipo de parâmetro.
    Por exemplo, `void Function(Object)` é um subtipo de `void Function(int)`
    porque `int` é um subtipo de `Object`.

    Com um tipo mais complexo como `List<void Function(int)>`,
    você precisa considerar as _positions_ (posições) no tipo.
    Para fazer isso, transforme uma das partes do tipo em um placeholder,
    e então considere o que acontece com o tipo quando
    diferentes tipos são colocados naquela posição.

    Por exemplo, considere `List<void Function(_)>` como um template para
    um tipo onde você pode colocar diferentes tipos no lugar do placeholder `_`.
    Este tipo é contravariante na posição onde aquele placeholder ocorre.

    O seguinte ilustra isso substituindo `Object` e `int` por `_`.
    `List<void Function(Object)>` é um subtipo de `List<void Function(int)>`
    porque `void Function(Object)` é um subtipo de `void Function(int)` porque
    `void` é um subtipo de `void` (os tipos de retorno) e
    `int` é um subtipo de `Object` (os tipos de parâmetro, na ordem oposta).
    Portanto, o tipo em `_` varia na direção oposta do
    tipo `List<void Function(_)>` como um todo, e essa
    'direção oposta' por definição faz dela uma _contravariant position_ (posição contravariante).

    Uma _covariant position_ (posição covariante) é definida similarmente.
    Por exemplo, `_` está em uma posição covariante no tipo `List<_>`,
    e `_` também está em uma posição covariante no tipo `_ Function(int)`.

    Existe ainda outro tipo de posição conhecido como _invariant_ (invariante),
    mas ocorre muito mais raramente então os detalhes são omitidos aqui.

    Na prática, é frequentemente suficiente saber que
    os argumentos de tipo de uma classe, mixin, etc. estão em uma posição covariante,
    e o mesmo vale para o tipo de retorno de um tipo de função, mas
    os tipos de parâmetro estão em uma posição contravariante.
  related_links:
    - text: "Relacionamento de subtipo"
      link: "#subtype"
      type: "term"
    - text: "Covariância e contravariância"
      link: "https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)"
      type: "article"
    - text: "A palavra-chave covariant"
      link: "/language/type-system#covariant-keyword"
      type: "doc"
  labels:
    - "language"
    - "type system"
    - "generics"
  alternate:
    - "variance positions"
    # TODO: Covariant and contravariant could/should have their own entries.
    - "covariance"
    - "covariant"
    - "contravariance"
    - "contravariant"

- term: "Wildcard"
  id: "wildcard"
  short_description: |-
    Um símbolo (`_`) usado no lugar de um nome de variável para
    indicar um valor não usado em patterns e outros contextos.
  long_description: |-
    Um wildcard é o caractere underscore (`_`) usado para
    ignorar valores ou indicar que um valor é intencionalmente não usado.
    É frequentemente usado em patterns, desestruturação e expressões switch para
    corresponder a qualquer valor sem vinculá-lo a um nome.

    Wildcards ajudam a tornar o código mais intencional ao marcar claramente
    valores que não são necessários em um contexto específico.

    Exemplo:

    ```dart
    // Ignoring the value in a for-each loop.
    var names = ['Alice', 'Bob', 'Charlie'];
    for (var _ in names) {
      print('Someone is here!');
    }
    ```

    O wildcard pattern é particularmente útil quando:

    - Você só precisa de certas partes de um valor desestruturado.
    - Você quer explicitamente mostrar que alguns valores estão sendo ignorados.
    - Você precisa de um caso catch-all em pattern matching.
  related_links:
    - text: "Variáveis wildcard"
      link: "/language/variables#wildcard-variables"
      type: "doc"
    - text: "Wildcard patterns"
      link: "/language/pattern-types#wildcard"
      type: "doc"
  labels:
    - "language"
    - "patterns"
    - "syntax"
  alternate:
    - "Underscore"
    - "Discard symbol"
    - "Pattern wildcard"
    - "Placeholder pattern"

- term: "Zone"
  id: "zone"
  short_description: |-
    Um mecanismo para customizar o comportamento de código assíncrono
    sem modificar o código assíncrono em si.
  long_description: |-
    Uma zone (zona) é um contexto de execução que permite que você execute código com
    comportamento customizado para eventos assíncronos como timers,
    microtasks e erros não capturados.

    Zones são úteis para:
    - Logging
    - Rastreamento de erros
    - Manter estado específico de requisição através de lacunas assíncronas
      (por exemplo, em apps de servidor)
    - Testar e debugar comportamento assíncrono

    Zones fornecem uma forma de rastrear e influenciar execução assíncrona
    sem exigir que o código assíncrono esteja ciente disso.

    Você pode criar uma nova zone usando `runZoned` (ou `runZonedGuarded`)
    e sobrescrever comportamento específico da zone como manipulação de erros e timers.
    Até `print` pode ser sobrescrito, embora não seja assíncrono e esteja
    incluído apenas por conveniência.

    Exemplo:
    ```dart
    import 'dart:async';

    void main() {
      runZonedGuarded(() {
        Future.delayed(Duration(seconds: 1), () {
          throw 'Zone caught this error!';
        });
      }, (error, stackTrace) {
        print('Caught error: $error');
      });
    }
    ```

    No exemplo anterior, o erro não capturado dentro do callback assíncrono
    é interceptado pela zone customizada.

  related_links:
    - text: "Documentação da API Zones"
      link: "https://api.dart.dev/stable/dart-async/Zone-class.html"
      type: "api"
    - text: "Manipulação de erros com zones"
      link: "https://dart.dev/articles/libraries/zones"
      type: "doc"
    - text: "runZonedGuarded"
      link: "https://api.dart.dev/stable/dart-async/runZonedGuarded.html"
      type: "api"
  labels:
    - "language"
    - "asynchronous"
    - "runtime"
  alternate:
    - "zones"
    - "dart zones"
    - "execution zone"
    - "runZoned"

- term: "Verified publisher"
  short_description: |-
    Um publisher de pacotes no site pub.dev cuja
    identidade foi verificada pelo pub.dev.
  long_description: |-
    Um _verified publisher_ (publisher verificado) é uma coleção de um ou mais usuários que
    são identificados com um nome de domínio único.
    A propriedade do nome de domínio é verificada pelo pub.dev,
    como para o [dart.dev publisher][] no pub.dev pela equipe Dart.

    [dart.dev publisher]: https://pub.dev/publishers/dart.dev
  related_links:
    - text: "Verified publishers"
      link: "/tools/pub/verified-publishers"
      type: "doc"
    - text: "Publicando pacotes como verified publisher"
      link: "/tools/pub/publishing#verified-publisher"
      type: "doc"
  labels:
    - "pub"
    - "packages"

- term: "Version constraint"
  short_description: |-
    Uma restrição associada a cada dependência que
    especifica com quais versões espera-se que um pacote funcione.
  long_description: |-
    Uma _version constraint_ (restrição de versão) é um intervalo especificado de versões compatíveis
    de uma [dependency][] para um pacote.
    Isso pode ser uma versão única (`0.3.0`) ou um intervalo de versões (`^1.2.1`).
    Embora `any` também seja permitido, por razões de desempenho não é recomendado.

    [Packages][] de biblioteca devem sempre especificar restrições de versão
    para cada uma de suas dependências não-dev.
    [Application packages][], por outro lado,
    podem permitir qualquer versão de suas dependências,
    já que usam o [lockfile][] para gerenciar suas versões de dependência.

    [dependency]: #dependency
    [packages]: #package
    [Application packages]: #application-package
    [lockfile]: #lockfile
  related_links:
    - text: "Restrições de versão"
      link: "/tools/pub/dependencies#version-constraints"
      type: "doc"
    - text: "Filosofia de versionamento do Pub"
      link: "/tools/pub/versioning"
      type: "doc"
    - text: "Sintaxe caret"
      link: "/tools/pub/dependencies#caret-syntax"
      type: "doc"
  labels:
    - "pub"
    - "packages"
